// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod medo {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod copiyer {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COPY_MODIFIER: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COPY_MODIFIER: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COPY_MODIFIER: [CopyModifier; 3] = [
  CopyModifier::CopyAll,
  CopyModifier::CopyOnly,
  CopyModifier::CopyExcept,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CopyModifier(pub i8);
#[allow(non_upper_case_globals)]
impl CopyModifier {
  pub const CopyAll: Self = Self(0);
  pub const CopyOnly: Self = Self(1);
  pub const CopyExcept: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CopyAll,
    Self::CopyOnly,
    Self::CopyExcept,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CopyAll => Some("CopyAll"),
      Self::CopyOnly => Some("CopyOnly"),
      Self::CopyExcept => Some("CopyExcept"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CopyModifier {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CopyModifier {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CopyModifier {
    type Output = CopyModifier;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CopyModifier {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CopyModifier {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CopyModifier {}
pub enum TaskOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Task<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Task<'a> {
  type Inner = Task<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Task<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_SOURCE_DIR: flatbuffers::VOffsetT = 8;
  pub const VT_TARGET_DIR: flatbuffers::VOffsetT = 10;
  pub const VT_TIMER: flatbuffers::VOffsetT = 12;
  pub const VT_DELETE_AFTER_COPY: flatbuffers::VOffsetT = 14;
  pub const VT_COPY_MODIFIER: flatbuffers::VOffsetT = 16;
  pub const VT_IS_ACTIVE: flatbuffers::VOffsetT = 18;
  pub const VT_CLEAN_TYPES: flatbuffers::VOffsetT = 20;
  pub const VT_GENERATE_EXCLUDE_FILE: flatbuffers::VOffsetT = 22;
  pub const VT_COLOR: flatbuffers::VOffsetT = 24;
  pub const VT_FILTERS: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Task { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TaskArgs<'args>
  ) -> flatbuffers::WIPOffset<Task<'bldr>> {
    let mut builder = TaskBuilder::new(_fbb);
    builder.add_timer(args.timer);
    if let Some(x) = args.filters { builder.add_filters(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    if let Some(x) = args.clean_types { builder.add_clean_types(x); }
    if let Some(x) = args.target_dir { builder.add_target_dir(x); }
    if let Some(x) = args.source_dir { builder.add_source_dir(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_generate_exclude_file(args.generate_exclude_file);
    builder.add_is_active(args.is_active);
    builder.add_copy_modifier(args.copy_modifier);
    builder.add_delete_after_copy(args.delete_after_copy);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Task::VT_NAME, Some(&"")).unwrap()}
  }
  #[inline]
  pub fn description(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Task::VT_DESCRIPTION, Some(&"")).unwrap()}
  }
  #[inline]
  pub fn source_dir(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Task::VT_SOURCE_DIR, Some(&"")).unwrap()}
  }
  #[inline]
  pub fn target_dir(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Task::VT_TARGET_DIR, Some(&"")).unwrap()}
  }
  #[inline]
  pub fn timer(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Task::VT_TIMER, Some(120000)).unwrap()}
  }
  #[inline]
  pub fn delete_after_copy(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Task::VT_DELETE_AFTER_COPY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn copy_modifier(&self) -> CopyModifier {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CopyModifier>(Task::VT_COPY_MODIFIER, Some(CopyModifier::CopyAll)).unwrap()}
  }
  #[inline]
  pub fn is_active(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Task::VT_IS_ACTIVE, Some(true)).unwrap()}
  }
  #[inline]
  pub fn clean_types(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Task::VT_CLEAN_TYPES, Some(Default::default())).unwrap()}
  }
  #[inline]
  pub fn generate_exclude_file(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Task::VT_GENERATE_EXCLUDE_FILE, Some(true)).unwrap()}
  }
  #[inline]
  pub fn color(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Task::VT_COLOR, Some(&"#454")).unwrap()}
  }
  #[inline]
  pub fn filters(&self) -> Option<Filter<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Filter>>(Task::VT_FILTERS, None)}
  }
}

impl flatbuffers::Verifiable for Task<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source_dir", Self::VT_SOURCE_DIR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("target_dir", Self::VT_TARGET_DIR, false)?
     .visit_field::<i64>("timer", Self::VT_TIMER, false)?
     .visit_field::<bool>("delete_after_copy", Self::VT_DELETE_AFTER_COPY, false)?
     .visit_field::<CopyModifier>("copy_modifier", Self::VT_COPY_MODIFIER, false)?
     .visit_field::<bool>("is_active", Self::VT_IS_ACTIVE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("clean_types", Self::VT_CLEAN_TYPES, false)?
     .visit_field::<bool>("generate_exclude_file", Self::VT_GENERATE_EXCLUDE_FILE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Filter>>("filters", Self::VT_FILTERS, false)?
     .finish();
    Ok(())
  }
}
pub struct TaskArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source_dir: Option<flatbuffers::WIPOffset<&'a str>>,
    pub target_dir: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timer: i64,
    pub delete_after_copy: bool,
    pub copy_modifier: CopyModifier,
    pub is_active: bool,
    pub clean_types: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub generate_exclude_file: bool,
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub filters: Option<flatbuffers::WIPOffset<Filter<'a>>>,
}
impl<'a> Default for TaskArgs<'a> {
  #[inline]
  fn default() -> Self {
    TaskArgs {
      name: None,
      description: None,
      source_dir: None,
      target_dir: None,
      timer: 120000,
      delete_after_copy: false,
      copy_modifier: CopyModifier::CopyAll,
      is_active: true,
      clean_types: None,
      generate_exclude_file: true,
      color: None,
      filters: None,
    }
  }
}

pub struct TaskBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TaskBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Task::VT_NAME, name);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Task::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_source_dir(&mut self, source_dir: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Task::VT_SOURCE_DIR, source_dir);
  }
  #[inline]
  pub fn add_target_dir(&mut self, target_dir: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Task::VT_TARGET_DIR, target_dir);
  }
  #[inline]
  pub fn add_timer(&mut self, timer: i64) {
    self.fbb_.push_slot::<i64>(Task::VT_TIMER, timer, 120000);
  }
  #[inline]
  pub fn add_delete_after_copy(&mut self, delete_after_copy: bool) {
    self.fbb_.push_slot::<bool>(Task::VT_DELETE_AFTER_COPY, delete_after_copy, false);
  }
  #[inline]
  pub fn add_copy_modifier(&mut self, copy_modifier: CopyModifier) {
    self.fbb_.push_slot::<CopyModifier>(Task::VT_COPY_MODIFIER, copy_modifier, CopyModifier::CopyAll);
  }
  #[inline]
  pub fn add_is_active(&mut self, is_active: bool) {
    self.fbb_.push_slot::<bool>(Task::VT_IS_ACTIVE, is_active, true);
  }
  #[inline]
  pub fn add_clean_types(&mut self, clean_types: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Task::VT_CLEAN_TYPES, clean_types);
  }
  #[inline]
  pub fn add_generate_exclude_file(&mut self, generate_exclude_file: bool) {
    self.fbb_.push_slot::<bool>(Task::VT_GENERATE_EXCLUDE_FILE, generate_exclude_file, true);
  }
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Task::VT_COLOR, color);
  }
  #[inline]
  pub fn add_filters(&mut self, filters: flatbuffers::WIPOffset<Filter<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Filter>>(Task::VT_FILTERS, filters);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TaskBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TaskBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Task<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Task<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Task");
      ds.field("name", &self.name());
      ds.field("description", &self.description());
      ds.field("source_dir", &self.source_dir());
      ds.field("target_dir", &self.target_dir());
      ds.field("timer", &self.timer());
      ds.field("delete_after_copy", &self.delete_after_copy());
      ds.field("copy_modifier", &self.copy_modifier());
      ds.field("is_active", &self.is_active());
      ds.field("clean_types", &self.clean_types());
      ds.field("generate_exclude_file", &self.generate_exclude_file());
      ds.field("color", &self.color());
      ds.field("filters", &self.filters());
      ds.finish()
  }
}
pub enum FilterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Filter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Filter<'a> {
  type Inner = Filter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Filter<'a> {
  pub const VT_DOCUMENT_TYPES: flatbuffers::VOffsetT = 4;
  pub const VT_DOCUMENT_UIDS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Filter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FilterArgs<'args>
  ) -> flatbuffers::WIPOffset<Filter<'bldr>> {
    let mut builder = FilterBuilder::new(_fbb);
    if let Some(x) = args.document_uids { builder.add_document_uids(x); }
    if let Some(x) = args.document_types { builder.add_document_types(x); }
    builder.finish()
  }


  #[inline]
  pub fn document_types(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Filter::VT_DOCUMENT_TYPES, Some(Default::default())).unwrap()}
  }
  #[inline]
  pub fn document_uids(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Filter::VT_DOCUMENT_UIDS, Some(Default::default())).unwrap()}
  }
}

impl flatbuffers::Verifiable for Filter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("document_types", Self::VT_DOCUMENT_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("document_uids", Self::VT_DOCUMENT_UIDS, false)?
     .finish();
    Ok(())
  }
}
pub struct FilterArgs<'a> {
    pub document_types: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub document_uids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for FilterArgs<'a> {
  #[inline]
  fn default() -> Self {
    FilterArgs {
      document_types: None,
      document_uids: None,
    }
  }
}

pub struct FilterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FilterBuilder<'a, 'b> {
  #[inline]
  pub fn add_document_types(&mut self, document_types: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Filter::VT_DOCUMENT_TYPES, document_types);
  }
  #[inline]
  pub fn add_document_uids(&mut self, document_uids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Filter::VT_DOCUMENT_UIDS, document_uids);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FilterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Filter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Filter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Filter");
      ds.field("document_types", &self.document_types());
      ds.field("document_uids", &self.document_uids());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Task`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_task_unchecked`.
pub fn root_as_task(buf: &[u8]) -> Result<Task, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Task>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Task` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_task_unchecked`.
pub fn size_prefixed_root_as_task(buf: &[u8]) -> Result<Task, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Task>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Task` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_task_unchecked`.
pub fn root_as_task_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Task<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Task<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Task` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_task_unchecked`.
pub fn size_prefixed_root_as_task_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Task<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Task<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Task and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Task`.
pub unsafe fn root_as_task_unchecked(buf: &[u8]) -> Task {
  flatbuffers::root_unchecked::<Task>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Task and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Task`.
pub unsafe fn size_prefixed_root_as_task_unchecked(buf: &[u8]) -> Task {
  flatbuffers::size_prefixed_root_unchecked::<Task>(buf)
}
#[inline]
pub fn finish_task_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Task<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_task_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Task<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Copiyer
}  // pub mod Medo

